// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: events.sql

package postgres

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const createEvent = `-- name: CreateEvent :exec
insert into events (id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring,
                    dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability,
                    participants_visibility, publish_time, start_time, finish_time, withdraw_time)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
`

type CreateEventParams struct {
	ID                     uuid.UUID `json:"id"`
	Type                   int32     `json:"type"`
	Availability           int32     `json:"availability"`
	Participation          int32     `json:"participation"`
	Tag                    string    `json:"tag"`
	Name                   string    `json:"name"`
	Description            string    `json:"description"`
	Rules                  string    `json:"rules"`
	Picture                string    `json:"picture"`
	DynamicScoring         bool      `json:"dynamic_scoring"`
	DynamicMax             int32     `json:"dynamic_max"`
	DynamicMin             int32     `json:"dynamic_min"`
	DynamicSolveThreshold  int32     `json:"dynamic_solve_threshold"`
	Registration           int32     `json:"registration"`
	ScoreboardAvailability int32     `json:"scoreboard_availability"`
	ParticipantsVisibility int32     `json:"participants_visibility"`
	PublishTime            time.Time `json:"publish_time"`
	StartTime              time.Time `json:"start_time"`
	FinishTime             time.Time `json:"finish_time"`
	WithdrawTime           time.Time `json:"withdraw_time"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.Type,
		arg.Availability,
		arg.Participation,
		arg.Tag,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Picture,
		arg.DynamicScoring,
		arg.DynamicMax,
		arg.DynamicMin,
		arg.DynamicSolveThreshold,
		arg.Registration,
		arg.ScoreboardAvailability,
		arg.ParticipantsVisibility,
		arg.PublishTime,
		arg.StartTime,
		arg.FinishTime,
		arg.WithdrawTime,
	)
	return err
}

const deleteEvent = `-- name: DeleteEvent :execrows
delete
from events
where id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEvent, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getEventByID = `-- name: GetEventByID :one
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
where id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Availability,
		&i.Participation,
		&i.Tag,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Picture,
		&i.DynamicScoring,
		&i.DynamicMax,
		&i.DynamicMin,
		&i.DynamicSolveThreshold,
		&i.Registration,
		&i.ScoreboardAvailability,
		&i.ParticipantsVisibility,
		&i.PublishTime,
		&i.StartTime,
		&i.FinishTime,
		&i.WithdrawTime,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getEventByTag = `-- name: GetEventByTag :one
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
where tag = $1
`

func (q *Queries) GetEventByTag(ctx context.Context, tag string) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByTag, tag)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Availability,
		&i.Participation,
		&i.Tag,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Picture,
		&i.DynamicScoring,
		&i.DynamicMax,
		&i.DynamicMin,
		&i.DynamicSolveThreshold,
		&i.Registration,
		&i.ScoreboardAvailability,
		&i.ParticipantsVisibility,
		&i.PublishTime,
		&i.StartTime,
		&i.FinishTime,
		&i.WithdrawTime,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getEventIDIfNotWithdrawn = `-- name: GetEventIDIfNotWithdrawn :one
select id
from events
where tag = $1
  and now() < withdraw_time
`

func (q *Queries) GetEventIDIfNotWithdrawn(ctx context.Context, tag string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getEventIDIfNotWithdrawn, tag)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getEventIDIfRunning = `-- name: GetEventIDIfRunning :one
select id
from events
where tag = $1
  and now() between publish_time and withdraw_time
`

func (q *Queries) GetEventIDIfRunning(ctx context.Context, tag string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getEventIDIfRunning, tag)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getEvents = `-- name: GetEvents :many
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
`

func (q *Queries) GetEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Availability,
			&i.Participation,
			&i.Tag,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Picture,
			&i.DynamicScoring,
			&i.DynamicMax,
			&i.DynamicMin,
			&i.DynamicSolveThreshold,
			&i.Registration,
			&i.ScoreboardAvailability,
			&i.ParticipantsVisibility,
			&i.PublishTime,
			&i.StartTime,
			&i.FinishTime,
			&i.WithdrawTime,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :execrows
update events
set type                    = $2,
    availability            = $3,
    name                    = $4,
    description             = $5,
    rules                   = $6,
    picture                 = $7,
    dynamic_scoring         = $8,
    dynamic_max             = $9,
    dynamic_min             = $10,
    dynamic_solve_threshold = $11,
    registration            = $12,
    scoreboard_availability = $13,
    participants_visibility = $14,
    publish_time            = $15,
    start_time              = $16,
    finish_time             = $17,
    withdraw_time           = $18,
    updated_at              = now(),
    updated_by              = $19
where id = $1
`

type UpdateEventParams struct {
	ID                     uuid.UUID     `json:"id"`
	Type                   int32         `json:"type"`
	Availability           int32         `json:"availability"`
	Name                   string        `json:"name"`
	Description            string        `json:"description"`
	Rules                  string        `json:"rules"`
	Picture                string        `json:"picture"`
	DynamicScoring         bool          `json:"dynamic_scoring"`
	DynamicMax             int32         `json:"dynamic_max"`
	DynamicMin             int32         `json:"dynamic_min"`
	DynamicSolveThreshold  int32         `json:"dynamic_solve_threshold"`
	Registration           int32         `json:"registration"`
	ScoreboardAvailability int32         `json:"scoreboard_availability"`
	ParticipantsVisibility int32         `json:"participants_visibility"`
	PublishTime            time.Time     `json:"publish_time"`
	StartTime              time.Time     `json:"start_time"`
	FinishTime             time.Time     `json:"finish_time"`
	WithdrawTime           time.Time     `json:"withdraw_time"`
	UpdatedBy              uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateEvent,
		arg.ID,
		arg.Type,
		arg.Availability,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Picture,
		arg.DynamicScoring,
		arg.DynamicMax,
		arg.DynamicMin,
		arg.DynamicSolveThreshold,
		arg.Registration,
		arg.ScoreboardAvailability,
		arg.ParticipantsVisibility,
		arg.PublishTime,
		arg.StartTime,
		arg.FinishTime,
		arg.WithdrawTime,
		arg.UpdatedBy,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateEventPicture = `-- name: UpdateEventPicture :execrows
update events
set picture = $2
where id = $1
`

type UpdateEventPictureParams struct {
	ID      uuid.UUID `json:"id"`
	Picture string    `json:"picture"`
}

func (q *Queries) UpdateEventPicture(ctx context.Context, arg UpdateEventPictureParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateEventPicture, arg.ID, arg.Picture)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
