// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: events.sql

package postgres

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const createEvent = `-- name: CreateEvent :exec
insert into events (id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring,
                    dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability,
                    participants_visibility, publish_time, start_time, finish_time, withdraw_time)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
`

type CreateEventParams struct {
	ID                     uuid.UUID `json:"id"`
	Type                   int32     `json:"type"`
	Availability           int32     `json:"availability"`
	Participation          int32     `json:"participation"`
	Tag                    string    `json:"tag"`
	Name                   string    `json:"name"`
	Description            string    `json:"description"`
	Rules                  string    `json:"rules"`
	Picture                string    `json:"picture"`
	DynamicScoring         bool      `json:"dynamic_scoring"`
	DynamicMax             int32     `json:"dynamic_max"`
	DynamicMin             int32     `json:"dynamic_min"`
	DynamicSolveThreshold  int32     `json:"dynamic_solve_threshold"`
	Registration           int32     `json:"registration"`
	ScoreboardAvailability int32     `json:"scoreboard_availability"`
	ParticipantsVisibility int32     `json:"participants_visibility"`
	PublishTime            time.Time `json:"publish_time"`
	StartTime              time.Time `json:"start_time"`
	FinishTime             time.Time `json:"finish_time"`
	WithdrawTime           time.Time `json:"withdraw_time"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.exec(ctx, q.createEventStmt, createEvent,
		arg.ID,
		arg.Type,
		arg.Availability,
		arg.Participation,
		arg.Tag,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Picture,
		arg.DynamicScoring,
		arg.DynamicMax,
		arg.DynamicMin,
		arg.DynamicSolveThreshold,
		arg.Registration,
		arg.ScoreboardAvailability,
		arg.ParticipantsVisibility,
		arg.PublishTime,
		arg.StartTime,
		arg.FinishTime,
		arg.WithdrawTime,
	)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
delete
from events
where id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteEventStmt, deleteEvent, id)
	return err
}

const getAllEvents = `-- name: GetAllEvents :many
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
`

func (q *Queries) GetAllEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.query(ctx, q.getAllEventsStmt, getAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Availability,
			&i.Participation,
			&i.Tag,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Picture,
			&i.DynamicScoring,
			&i.DynamicMax,
			&i.DynamicMin,
			&i.DynamicSolveThreshold,
			&i.Registration,
			&i.ScoreboardAvailability,
			&i.ParticipantsVisibility,
			&i.PublishTime,
			&i.StartTime,
			&i.FinishTime,
			&i.WithdrawTime,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
where id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.queryRow(ctx, q.getEventByIDStmt, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Availability,
		&i.Participation,
		&i.Tag,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Picture,
		&i.DynamicScoring,
		&i.DynamicMax,
		&i.DynamicMin,
		&i.DynamicSolveThreshold,
		&i.Registration,
		&i.ScoreboardAvailability,
		&i.ParticipantsVisibility,
		&i.PublishTime,
		&i.StartTime,
		&i.FinishTime,
		&i.WithdrawTime,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getEventByTag = `-- name: GetEventByTag :one
select id, type, availability, participation, tag, name, description, rules, picture, dynamic_scoring, dynamic_max, dynamic_min, dynamic_solve_threshold, registration, scoreboard_availability, participants_visibility, publish_time, start_time, finish_time, withdraw_time, updated_at, updated_by, created_at
from events
where tag = $1
`

func (q *Queries) GetEventByTag(ctx context.Context, tag string) (Event, error) {
	row := q.queryRow(ctx, q.getEventByTagStmt, getEventByTag, tag)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Availability,
		&i.Participation,
		&i.Tag,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Picture,
		&i.DynamicScoring,
		&i.DynamicMax,
		&i.DynamicMin,
		&i.DynamicSolveThreshold,
		&i.Registration,
		&i.ScoreboardAvailability,
		&i.ParticipantsVisibility,
		&i.PublishTime,
		&i.StartTime,
		&i.FinishTime,
		&i.WithdrawTime,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getEventIDIfNotWithdrawn = `-- name: GetEventIDIfNotWithdrawn :one
select id
from events
where tag = $1
  and now() < withdraw_time
`

func (q *Queries) GetEventIDIfNotWithdrawn(ctx context.Context, tag string) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getEventIDIfNotWithdrawnStmt, getEventIDIfNotWithdrawn, tag)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getEventIDIfRunning = `-- name: GetEventIDIfRunning :one
select id
from events
where tag = $1
  and now() between publish_time and withdraw_time
`

func (q *Queries) GetEventIDIfRunning(ctx context.Context, tag string) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getEventIDIfRunningStmt, getEventIDIfRunning, tag)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updateEvent = `-- name: UpdateEvent :exec
update events
set name                    = $2,
    description             = $3,
    rules                   = $4,
    picture                 = $5,
    dynamic_scoring         = $6,
    dynamic_max             = $7,
    dynamic_min             = $8,
    dynamic_solve_threshold = $9,
    registration            = $10,
    scoreboard_availability = $11,
    participants_visibility = $12,
    publish_time            = $13,
    start_time              = $14,
    finish_time             = $15,
    withdraw_time           = $16
where id = $1
`

type UpdateEventParams struct {
	ID                     uuid.UUID `json:"id"`
	Name                   string    `json:"name"`
	Description            string    `json:"description"`
	Rules                  string    `json:"rules"`
	Picture                string    `json:"picture"`
	DynamicScoring         bool      `json:"dynamic_scoring"`
	DynamicMax             int32     `json:"dynamic_max"`
	DynamicMin             int32     `json:"dynamic_min"`
	DynamicSolveThreshold  int32     `json:"dynamic_solve_threshold"`
	Registration           int32     `json:"registration"`
	ScoreboardAvailability int32     `json:"scoreboard_availability"`
	ParticipantsVisibility int32     `json:"participants_visibility"`
	PublishTime            time.Time `json:"publish_time"`
	StartTime              time.Time `json:"start_time"`
	FinishTime             time.Time `json:"finish_time"`
	WithdrawTime           time.Time `json:"withdraw_time"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.exec(ctx, q.updateEventStmt, updateEvent,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Picture,
		arg.DynamicScoring,
		arg.DynamicMax,
		arg.DynamicMin,
		arg.DynamicSolveThreshold,
		arg.Registration,
		arg.ScoreboardAvailability,
		arg.ParticipantsVisibility,
		arg.PublishTime,
		arg.StartTime,
		arg.FinishTime,
		arg.WithdrawTime,
	)
	return err
}
