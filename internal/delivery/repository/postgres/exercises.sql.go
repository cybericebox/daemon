// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: exercises.sql

package postgres

import (
	"context"
	"encoding/json"

	"github.com/gofrs/uuid"
)

const createExercise = `-- name: CreateExercise :exec
insert into exercises
    (id, category_id, name, description, data)
values ($1, $2, $3, $4, $5)
`

type CreateExerciseParams struct {
	ID          uuid.UUID       `json:"id"`
	CategoryID  uuid.UUID       `json:"category_id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) error {
	_, err := q.exec(ctx, q.createExerciseStmt, createExercise,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Data,
	)
	return err
}

const deleteExercise = `-- name: DeleteExercise :exec
delete
from exercises
where id = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteExerciseStmt, deleteExercise, id)
	return err
}

const getExerciseByID = `-- name: GetExerciseByID :one
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where id = $1
`

func (q *Queries) GetExerciseByID(ctx context.Context, id uuid.UUID) (Exercise, error) {
	row := q.queryRow(ctx, q.getExerciseByIDStmt, getExerciseByID, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExercises = `-- name: GetExercises :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
`

func (q *Queries) GetExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.query(ctx, q.getExercisesStmt, getExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByCategory = `-- name: GetExercisesByCategory :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where category_id = $1
`

func (q *Queries) GetExercisesByCategory(ctx context.Context, categoryID uuid.UUID) ([]Exercise, error) {
	rows, err := q.query(ctx, q.getExercisesByCategoryStmt, getExercisesByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExercise = `-- name: UpdateExercise :exec
update exercises
set category_id = $2,
    name        = $3,
    description = $4,
    data        = $5
where id = $1
`

type UpdateExerciseParams struct {
	ID          uuid.UUID       `json:"id"`
	CategoryID  uuid.UUID       `json:"category_id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) error {
	_, err := q.exec(ctx, q.updateExerciseStmt, updateExercise,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Data,
	)
	return err
}
