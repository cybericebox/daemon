// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: exercises.sql

package postgres

import (
	"context"

	"github.com/cybericebox/daemon/internal/model"
	"github.com/gofrs/uuid"
)

const createExercise = `-- name: CreateExercise :exec
insert into exercises
    (id, category_id, name, description, data)
values ($1, $2, $3, $4, $5)
`

type CreateExerciseParams struct {
	ID          uuid.UUID          `json:"id"`
	CategoryID  uuid.UUID          `json:"category_id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Data        model.ExerciseData `json:"data"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) error {
	_, err := q.db.Exec(ctx, createExercise,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Data,
	)
	return err
}

const deleteExercise = `-- name: DeleteExercise :execrows
delete
from exercises
where id = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExercise, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getExerciseByID = `-- name: GetExerciseByID :one
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where id = $1
`

func (q *Queries) GetExerciseByID(ctx context.Context, id uuid.UUID) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExerciseByID, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Data,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExercises = `-- name: GetExercises :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
order by name
`

func (q *Queries) GetExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, getExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByCategory = `-- name: GetExercisesByCategory :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where category_id = $1
order by name
`

func (q *Queries) GetExercisesByCategory(ctx context.Context, categoryID uuid.UUID) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, getExercisesByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByIDs = `-- name: GetExercisesByIDs :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where id = any ($1::uuid[])
order by name
`

func (q *Queries) GetExercisesByIDs(ctx context.Context, ids []uuid.UUID) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, getExercisesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesWithSimilarName = `-- name: GetExercisesWithSimilarName :many
select id, category_id, name, description, data, updated_at, updated_by, created_at
from exercises
where name ilike '%' || $1::text || '%'
   or description ilike '%' || $1::text || '%'
order by name
`

func (q *Queries) GetExercisesWithSimilarName(ctx context.Context, search string) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, getExercisesWithSimilarName, search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Data,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExercise = `-- name: UpdateExercise :execrows
update exercises
set category_id = $2,
    name        = $3,
    description = $4,
    data        = $5,
    updated_at  = now(),
    updated_by  = $6
where id = $1
`

type UpdateExerciseParams struct {
	ID          uuid.UUID          `json:"id"`
	CategoryID  uuid.UUID          `json:"category_id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Data        model.ExerciseData `json:"data"`
	UpdatedBy   uuid.NullUUID      `json:"updated_by"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateExercise,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Data,
		arg.UpdatedBy,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
