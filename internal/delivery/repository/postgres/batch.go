// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: batch.go

package postgres

import (
	"context"
	"errors"

	"github.com/cybericebox/daemon/internal/model"
	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createEventChallenge = `-- name: CreateEventChallenge :batchexec
insert into event_challenges
(id, event_id, category_id, data, order_index, exercise_id, exercise_task_id)
values ($1, $2, $3, $4, $5, $6, $7)
`

type CreateEventChallengeBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateEventChallengeParams struct {
	ID             uuid.UUID           `json:"id"`
	EventID        uuid.UUID           `json:"event_id"`
	CategoryID     uuid.UUID           `json:"category_id"`
	Data           model.ChallengeData `json:"data"`
	OrderIndex     int32               `json:"order_index"`
	ExerciseID     uuid.UUID           `json:"exercise_id"`
	ExerciseTaskID uuid.UUID           `json:"exercise_task_id"`
}

func (q *Queries) CreateEventChallenge(ctx context.Context, arg []CreateEventChallengeParams) *CreateEventChallengeBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.EventID,
			a.CategoryID,
			a.Data,
			a.OrderIndex,
			a.ExerciseID,
			a.ExerciseTaskID,
		}
		batch.Queue(createEventChallenge, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateEventChallengeBatchResults{br, len(arg), false}
}

func (b *CreateEventChallengeBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateEventChallengeBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createEventTeamChallenge = `-- name: CreateEventTeamChallenge :batchexec
insert into event_team_challenges
    (id, event_id, team_id, challenge_id, flag)
values ($1, $2, $3, $4, $5) on conflict do nothing
`

type CreateEventTeamChallengeBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateEventTeamChallengeParams struct {
	ID          uuid.UUID `json:"id"`
	EventID     uuid.UUID `json:"event_id"`
	TeamID      uuid.UUID `json:"team_id"`
	ChallengeID uuid.UUID `json:"challenge_id"`
	Flag        string    `json:"flag"`
}

func (q *Queries) CreateEventTeamChallenge(ctx context.Context, arg []CreateEventTeamChallengeParams) *CreateEventTeamChallengeBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.EventID,
			a.TeamID,
			a.ChallengeID,
			a.Flag,
		}
		batch.Queue(createEventTeamChallenge, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateEventTeamChallengeBatchResults{br, len(arg), false}
}

func (b *CreateEventTeamChallengeBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateEventTeamChallengeBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const deleteEventChallenges = `-- name: DeleteEventChallenges :batchexec
delete
from event_challenges
where exercise_id = $1
  and event_id = $2
`

type DeleteEventChallengesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type DeleteEventChallengesParams struct {
	ExerciseID uuid.UUID `json:"exercise_id"`
	EventID    uuid.UUID `json:"event_id"`
}

func (q *Queries) DeleteEventChallenges(ctx context.Context, arg []DeleteEventChallengesParams) *DeleteEventChallengesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ExerciseID,
			a.EventID,
		}
		batch.Queue(deleteEventChallenges, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &DeleteEventChallengesBatchResults{br, len(arg), false}
}

func (b *DeleteEventChallengesBatchResults) Exec(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, 0, ErrBatchAlreadyClosed)
			}
			continue
		}
		res, err := b.br.Exec()
		if f != nil {
			f(t, res.RowsAffected(), err)
		}
	}
}

func (b *DeleteEventChallengesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const deleteFile = `-- name: DeleteFile :batchexec
delete
from files
where id = $1
`

type DeleteFileBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) DeleteFile(ctx context.Context, id []uuid.UUID) *DeleteFileBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(deleteFile, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &DeleteFileBatchResults{br, len(id), false}
}

func (b *DeleteFileBatchResults) Exec(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, 0, ErrBatchAlreadyClosed)
			}
			continue
		}
		res, err := b.br.Exec()
		if f != nil {
			f(t, res.RowsAffected(), err)
		}
	}
}

func (b *DeleteFileBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updateEventChallengeCategoryOrder = `-- name: UpdateEventChallengeCategoryOrder :batchexec
update event_challenge_categories
set order_index = $3,
    updated_at = now(),
    updated_by = $4
where id = $1
  and event_id = $2
`

type UpdateEventChallengeCategoryOrderBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpdateEventChallengeCategoryOrderParams struct {
	ID         uuid.UUID     `json:"id"`
	EventID    uuid.UUID     `json:"event_id"`
	OrderIndex int32         `json:"order_index"`
	UpdatedBy  uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) UpdateEventChallengeCategoryOrder(ctx context.Context, arg []UpdateEventChallengeCategoryOrderParams) *UpdateEventChallengeCategoryOrderBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.EventID,
			a.OrderIndex,
			a.UpdatedBy,
		}
		batch.Queue(updateEventChallengeCategoryOrder, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateEventChallengeCategoryOrderBatchResults{br, len(arg), false}
}

func (b *UpdateEventChallengeCategoryOrderBatchResults) Exec(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, 0, ErrBatchAlreadyClosed)
			}
			continue
		}
		res, err := b.br.Exec()
		if f != nil {
			f(t, res.RowsAffected(), err)
		}
	}
}

func (b *UpdateEventChallengeCategoryOrderBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updateEventChallengeOrder = `-- name: UpdateEventChallengeOrder :batchexec
update event_challenges
set category_id = $3,
    order_index = $4,
    updated_at = now(),
    updated_by = $5
where id = $1
  and event_id = $2
`

type UpdateEventChallengeOrderBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpdateEventChallengeOrderParams struct {
	ID         uuid.UUID     `json:"id"`
	EventID    uuid.UUID     `json:"event_id"`
	CategoryID uuid.UUID     `json:"category_id"`
	OrderIndex int32         `json:"order_index"`
	UpdatedBy  uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) UpdateEventChallengeOrder(ctx context.Context, arg []UpdateEventChallengeOrderParams) *UpdateEventChallengeOrderBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.EventID,
			a.CategoryID,
			a.OrderIndex,
			a.UpdatedBy,
		}
		batch.Queue(updateEventChallengeOrder, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateEventChallengeOrderBatchResults{br, len(arg), false}
}

func (b *UpdateEventChallengeOrderBatchResults) Exec(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, 0, ErrBatchAlreadyClosed)
			}
			continue
		}
		res, err := b.br.Exec()
		if f != nil {
			f(t, res.RowsAffected(), err)
		}
	}
}

func (b *UpdateEventChallengeOrderBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
